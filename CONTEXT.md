### ConText (working title)...

... is an object-oriented virtual filesystem, intended to facilitate data comprehension, documentation, and organization. Users can interact with the object system through a scrapbook style browser, or through any traditional desktop software running on Windows.

Anything that can be modelled as a serializable Python object can be put into the object system. Out of the box, ConText browser provides Text, Ink, Image, File, Script, Website, and Page objects, making the ConText browser suitable for notekeeping and bookmarking. Pages are objects that contain other objects. Thus they can function as documents, directories, or both simultaneously. Ordinary files can be organized within the virtual object system without being moved on the users's hard drive.

ConText instances can be shared as a notebook file. When many copies of the same notebook are opened they can synchronize with eachother using a peer-to-peer mechanism, either to collaborate or just to have many simultaneous input devices. Compared to publicly hosting a collaborative editing web app, this requires no significant server hardware, and also allows the user complete control over data sharing and locality.

If ConText detects that any objects are cloud-synced files (Drive, Dropbox), it will find those objects' locations on other devices where ConText is running and make them available within the browser. If cloud sync is not available for a file object, one Context instance can attempt to transmit the data to another if the object is accessed. If ConText detects any objects are in a repository, it will track the version of those objects as they are accessed. If running in the background, ConText will attempt to track movement of files on the native filesystem in order to update references to old file locations.

There are two overarching goals of ConText. The first is to provide a way to keep notes, data, and code close together, independent of their true storage locations. Consider how this makes scripts easier to write: data Files can always be loaded from the Script's working directory, by placing the Script and data File objects on the same Page. Since version control state is tracked, you also always know which version of a codebase was used to produce a result. You can keep the data, code, results, and notes all in one package, which can be easily disseminated, reviewed, and re-evaluated by anyone with all of the original context still present. 

The second goal is to streamline context-switching between different toolsets. E.g, some notes are typed, other notes are hand-written, data is collected from instruments and saved onto flash drives, software is used to produce designs. With ConText all of this information can be written into one virutal space. You can type into the notebook at your desktop, and draw onto the same page with your tablet, you can drag files directly into the notebook for viewing and analysis, and write descriptions directly under them, and you can access the virtual filesystem in your design software to work with those same files, or to save a design into the notebook.

Objects in ConText are first-class Python objects, so Python code written by users or developers can interact with them directly. Within the browser, the user can execute a Script that reads the data on a page or manipulates the page content. Integration of IPython and Matplotlib will provide a scientific Python environment directly in the browser, similar to Jupyter Notebook / Google Colab. Alternatively you could use a separate IDE while still interacting with the page contents via the virtual filesystem.

New object types offering custom functionality can be coded as Python classes. Custom visual rendering of objects within the browser can be implemented in ES6 + React.js. Back-end modules written in any language can make remote procedure calls on ConText objects via websocket. ConText object classes must fulfill certain obligations such as encapsulating all persistent data as a JSON-serializable value, and defining all mutibility of the data through a transaction API which integrates with the system's persistence, synchronization, and version control. 
